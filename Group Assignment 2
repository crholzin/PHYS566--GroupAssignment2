# -*- coding: utf-8 -*-
"""
Created on Mon Apr  6 10:27:20 2015

@author: kevinhe
"""



import random
import pylab
import numpy
import matplotlib as mpl

import sys
sys.setrecursionlimit=10**7
'''
increase the system's tolerance of recursion limits
'''

def gene(n):
    '''
    generate empty list of lists that store the info of each grid point
    0 stands for unoccupied 
    1 stands for occupied and percolated
    -1 stands for occupied but not percolated
    '''
    
    return [[0 for i in range(n)] for j in range(n)]

def genlocs(n):
    '''
    generate a list of all initial available locations in tuples
    '''
    locs=[]
    for i in range(n):
        for j in range(n):
            locs+=[(i,j)]
    return locs

def ranpop(locs):
    '''
    randomly choose one the locs (which is a list storing the locations)
    return the chosen one while removing it from the list locs
    '''
    one=random.choice(locs)
    return locs.pop(locs.index(one))

def adj(m,loc):
    '''
    return a list of coordinates of all adjacent points
    of all occupied grid
    '''    
    
    n=len(m)
    (i,j)=loc
    xys=[(i+1,j),(i-1,j),(i,j+1),(i,j-1)]
    if i+1>=n:
        xys.remove((i+1,j))
    if i-1<=-1:
        xys.remove((i-1,j))
    if j+1>=n:
        xys.remove((i,j+1))
    if j-1<=-1:
        xys.remove((i,j-1))
    return [(ii,jj) for (ii,jj) in xys if m[ii][jj]!=0]

def adjvs(m,loc):
    '''
    return the values of all adjacent occupied points 
    '''
    return [m[ii][jj] for (ii,jj) in adj(m,loc)]

def notcomp(m):
    '''
    check if the percolation process is complete
    '''
    if 1 in m[0]:
        return False
    return True
    
def perco(m,loc):
    '''
    use recursion to assign the percolated pointed value 1
    '''
    (i,j)=loc
    m[i][j]=1
    if -1 in adjvs(m,loc):
        for (i1,j1) in adj(m,loc):
            if m[i1][j1]==-1:
                perco(m,(i1,j1))
        
def main(n):
    '''
    the main function, which takes n as the argument and procduce the 
    simulation for percolation, return the grid and the proportion of occupation
    '''
    m=gene(n)
    locs=genlocs(n)
    while notcomp(m):
        (i,j)=ranpop(locs)
        if i==n-1 or (1 in adjvs(m,(i,j))):
            perco(m,(i,j))
        else:
            m[i][j]=-1
        print n**2-len(locs)
        mplot(m)
    p=float((n**2-len(locs)))/n**2
    return (m,p)
    
def mplot(m,name=''):
    '''
    plot the grid
    if there is another argument called name is assigned a non-empty value
    the picture would be saved under that name
    '''
    cmap = mpl.colors.ListedColormap(['red','white','blue'])
    pylab.imshow(numpy.array(m),cmap=cmap,vmin=-1,vmax=1,origin='lower',interpolation='nearest')
    pylab.xlabel('x')
    pylab.ylabel('y')
    if name!='':
        pylab.savefig(name+'.eps')
    pylab.show()
    
    
'''
n=50
for k in range(10):
    (m,p)=main(n)
    print 'p is', p
'''
